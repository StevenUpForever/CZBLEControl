///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the auth namespace
open class Auth {
    /// Errors occurred during authentication.
    public enum AuthError: CustomStringConvertible {
        /// The access token is invalid.
        case invalidAccessToken
        /// The user specified in 'Dropbox-API-Select-User' is no longer on the team.
        case invalidSelectUser
        /// The user specified in 'Dropbox-API-Select-Admin' is not a Dropbox Business team admin.
        case invalidSelectAdmin
        /// The user has been suspended.
        case userSuspended
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AuthErrorSerializer().serialize(self)))"
        }
    }
    open class AuthErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AuthError) -> JSON {
            switch value {
                case .invalidAccessToken:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_access_token")
                    return .dictionary(d)
                case .invalidSelectUser:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_select_user")
                    return .dictionary(d)
                case .invalidSelectAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_select_admin")
                    return .dictionary(d)
                case .userSuspended:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_suspended")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AuthError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_access_token":
                            return AuthError.invalidAccessToken
                        case "invalid_select_user":
                            return AuthError.invalidSelectUser
                        case "invalid_select_admin":
                            return AuthError.invalidSelectAdmin
                        case "user_suspended":
                            return AuthError.userSuspended
                        case "other":
                            return AuthError.other
                        default:
                            return AuthError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Error occurred because the app is being rate limited.
    open class RateLimitError: CustomStringConvertible {
        /// The reason why the app is being rate limited.
        open let reason: Auth.RateLimitReason
        /// The number of seconds that the app should wait before making another request.
        open let retryAfter: UInt64
        public init(reason: Auth.RateLimitReason, retryAfter: UInt64 = 1) {
            self.reason = reason
            comparableValidator()(retryAfter)
            self.retryAfter = retryAfter
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RateLimitErrorSerializer().serialize(self)))"
        }
    }
    open class RateLimitErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RateLimitError) -> JSON {
            let output = [
            "reason": Auth.RateLimitReasonSerializer().serialize(value.reason),
            "retry_after": Serialization._UInt64Serializer.serialize(value.retryAfter),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RateLimitError {
            switch json {
                case .dictionary(let dict):
                    let reason = Auth.RateLimitReasonSerializer().deserialize(dict["reason"] ?? .null)
                    let retryAfter = Serialization._UInt64Serializer.deserialize(dict["retry_after"] ?? .number(1))
                    return RateLimitError(reason: reason, retryAfter: retryAfter)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RateLimitReason union
    public enum RateLimitReason: CustomStringConvertible {
        /// You are making too many requests in the past few minutes.
        case tooManyRequests
        /// There are currently too many write operations happening in the user's Dropbox.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RateLimitReasonSerializer().serialize(self)))"
        }
    }
    open class RateLimitReasonSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RateLimitReason) -> JSON {
            switch value {
                case .tooManyRequests:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_requests")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RateLimitReason {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_requests":
                            return RateLimitReason.tooManyRequests
                        case "too_many_write_operations":
                            return RateLimitReason.tooManyWriteOperations
                        case "other":
                            return RateLimitReason.other
                        default:
                            return RateLimitReason.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let tokenRevoke = Route(
        name: "token/revoke",
        namespace: "auth",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
